# Система бронирования отелей - задание

## Введение

Проект представляет собой разработку REST API для системы бронирования отелей на базе Spring Boot с использованием микросервисной архитектуры.

Цель проекта - создать распределенное приложение с несколькими сервисами, реализующими основные функции бронирования, управления гостиницами и маршрутизации запросов через API Gateway.

Особое внимание в проекте будет уделено:

- Безопасной аутентификации и авторизации (JWT, роли USER и ADMIN).
- Реализации алгоритма планирования занятости номеров (на основе данных о бронированиях без применения продвинутых статистических методов).
- Организации согласованности данных между сервисами через двухшаговое подтверждение с отменой при сбое.

Проект позволит закрепить знания по Spring Boot, Spring Cloud, REST API, JPA/Hibernate и продемонстрировать умение строить распределенные системы.

## Что нужно сделать

Приложение должно состоять из следующих компонентов:

- API Gateway (Spring Cloud Gateway) - шлюз, осуществляющий маршрутизацию запросов, прокси-передачу JWT в backend-сервисы, проверку доступа на входе и/или на сервисах согласно выбранной схеме.
- Hotel Management Service - управление отелями и номерами (CRUD), агрегации по загруженности.
- Booking Service - создание бронирований и управление ими, интеграция с Hotel Service, регистрация и авторизация пользователей, администрирование. Booking Service создаёт бронирование в статусе PENDING, запрашивает подтверждение доступности номера у Hotel Service. При успешном ответе переводит бронирование в CONFIRMED, при сбое выполняет компенсацию (отменяет бронирование).
- Eureka Server - сервер регистрации и динамического обнаружения сервисов.

Каждый сервис должен быть самостоятельным Spring Boot приложением с in-memory базой данных (H2).

### Рекомендации по использованию библиотек

- Java 17+ (будет использоваться версия 21).
- Spring Boot 3.5.x (будет использоваться версия 3.5.6).
- Spring Cloud релиз-трейн, совместимый со Spring Boot по BOM (будет использоваться 2025.0 Northfields).
- Spring Data JPA + H2 (in-memory).
- Spring Security + JWT (реализация на усмотрение, совместимая со Spring Security).
- Spring Cloud Eureka (Service Discovery).
- Spring Cloud Gateway (API Gateway).
- Lombok, MapStruct (для DTO и маппинга).

### Требования к структуре системы

#### Компоненты системы

- API Gateway (Spring Cloud Gateway) - шлюз, осуществляющий маршрутизацию запросов, передачу токена для проверки в сервисах.
- Hotel Management Service - микросервис для управления отелями и номерами (CRUD), агрегации по загруженности.
- Booking Service - микросервис для создания бронирований и управления ими, интеграции с Hotel Service, регистрации и авторизации пользователей, администрирования.
- Eureka Server - реализация Service Registry (реестр сервисов). Его основная задача - обеспечивать динамическое обнаружение сервисов (service discovery) в микросервисной архитектуре.

#### Слои микросервисов

- Entities (JPA): User, Booking, Hotel, Room.
- Repositories: JpaRepository для CRUD.
- Services: бизнес-логика (планирование занятости, бронирование, согласованность данных между сервисами).
- Controllers: REST API.
- Security: Resource Server с проверкой JWT внутри каждого сервиса.
- Операции БД внутри каждого сервиса выполняются в локальных транзакциях (@Transactional).

### Функциональные требования

#### Пользователи

- Регистрация и вход (JWT).
- Просмотр доступных отелей и номеров.
- Создание бронирования.
- Просмотр своей истории бронирований.

#### Администраторы

- CRUD-операции с отелями, номерами и пользователями.
- Просмотр статистики загруженности номеров.

#### Алгоритмы

Эффективное планирование занятости номеров:

- Hotel Service ведёт статистику (количество бронирований номера).
- Booking Service при автоматическом подборе комнаты предлагает комнаты на основе агрегированных данных о бронированиях (например, счётчика times_booked), стремясь к равномерной загрузке без «простоя».
- Booking Service возвращает список номеров, отсортированный по возрастанию times_booked (при равенстве - по идентификатору).

#### Распределённая многопоточная транзакция

При создании бронирования используется двухшаговая согласованность между сервисами.

- Booking Service выполняет локальную транзакцию: создаёт бронирование в статусе PENDING и фиксирует его в своей базе данных.
- Booking Service вызывает Hotel Management Service для подтверждения доступности номера. При успешном ответе бронирование переводится в статус CONFIRMED. При ошибке или истечении времени ожидания выполняется компенсация: бронирование переводится в статус CANCELLED, временная блокировка слота в Hotel Service снимается (через эндпойнт POST /api/rooms/{id}/release), если на этапе подтверждения доступности была установлена блокировка.

#### Технические требования к реализации

- Взаимодействие между сервисами бронирований и управления отелями выполняется как последовательность локальных транзакций; глобальные распределённые транзакции не используются.
- Для удалённых вызовов обязательно задать тайм-аут и ограниченное число повторов с увеличением интервала между попытками; при исчерпании попыток выполняется компенсация.
- Операции должны быть идемпотентными: повторная обработка одного запроса (например, при повторах/тайм-аутах) не создаёт дубликатов и не приводит к повторной смене доступности номера. Для этого в каждом запросе используется корреляционный идентификатор (например, requestId), по которому определяется, обрабатывался ли он ранее.
- Сквозная корреляция: все действия в рамках одного бронирования маркируются единым идентификатором (например, bookingId); ключевые шаги процесса логируются с этим идентификатором.
- Управление состояниями бронирования: PENDING -> CONFIRMED при успешном подтверждении доступности номера; PENDING -> CANCELLED при ошибке или истечении времени ожидания, с выполнением компенсации.
- Потоконебезопасных общих объектов и гонок данных быть не должно; при конкурентных попытках бронирования одного и того же номера на пересекающиеся даты система должна корректно отказывать без создания дубликатов (возврат 409 или эквивалентной ошибки) либо повторять попытку по правилам повторов.
- Проверяемость: реализовать тестовые сценарии успеха, ошибки удалённого сервиса, тайм-аута и повторной доставки запроса; в логах должны прослеживаться переходы состояний и результат компенсации.
- Разграничение доступа сохраняется: операции бронирования доступны авторизованным пользователям, административные операции - только администраторам.

### Примерная структура эндпойнтов приложения

Все публичные REST-эндпойнты публикуются под префиксом `/api` и доступны через Gateway.

#### Gateway (маршрутизация)

- /api/bookings/** -> Booking Service.
- /api/hotels/** -> Hotel Service.

#### Booking Service

- DELETE /api/user - удалить пользователя (ADMIN).
- POST /api/user - создать пользователя (ADMIN).
- PATCH /api/user - обновить данные пользователя (ADMIN).
- POST /api/booking - создать бронирование (с выбором или автоподбором комнаты) (USER). В теле запроса параметр autoSelect: true/false (при true поле roomId игнорируется).
- GET /api/bookings - история бронирований пользователя (USER).
- POST /api/user/register - зарегистрировать пользователя, сгенерировав токен (USER).
- POST /api/user/auth - авторизовать пользователя, сгенерировав токен (USER).
- GET /api/booking/{id} - получить бронирование по id (USER).
- DELETE /api/booking/{id} - отменить бронирование (USER).

#### Hotel Management Service

- POST /api/hotels - добавить отель (ADMIN).
- POST /api/rooms - добавить номер в отель (ADMIN).
- GET /api/hotels - получить список отелей (USER).
- GET /api/rooms/recommend - получить список рекомендованных номеров (USER) (те же свободные номера, отсортированные по возрастанию times_booked).
- GET /api/rooms - получить список всех свободных номеров (USER) (без специальной сортировки).
- POST /api/rooms/{id}/confirm-availability - подтвердить доступность номера на запрошенные даты (временная блокировка слота на указанный период, используется в шаге согласованности) (INTERNAL).
- POST /api/rooms/{id}/release - компенсирующее действие: снять временную блокировку слота (INTERNAL). Маршрут не публикуется через Gateway.

### Требования к базе данных

Booking Service (in-memory H2):

- Таблица users: id, username, password, role.
- Таблица bookings: id, user_id, room_id, start_date, end_date, status (PENDING/CONFIRMED/CANCELLED), created_at.

Hotel Management Service (in-memory H2):

- Таблица hotels: id, name, address.
- Таблица rooms: id, hotel_id, number, available, times_booked.

В требованиях указаны минимальные таблицы и поля, по вашему усмотрению допускается добавление дополнительных данных.

Примечание: поле AVAILABLE отражает операционную доступность номера (например, ремонт/вывод из эксплуатации) и не используется для проверки занятости по датам; занятость определяется по таблице BOOKINGS (START_DATE, END_DATE).

### Требования к безопасности

- JWT-аутентификация (срок действия токена - один час).
- Разграничение ролей:
  - USER - только личные операции.
  - ADMIN - операции с отелями, номерами и пользователями.
- Каждый сервис проверяет JWT самостоятельно (Resource Server), Gateway выполняет маршрутизацию.

### Дополнительные требования

- Swagger/OpenAPI-документация.
- Тестирование (JUnit + MockMvc).

## Сдача проекта

### Этапы сдачи проекта

#### Размещение кода на GitHub

Код проекта необходимо загрузить в свой GitHub-репозиторий.

Также необходимо убедиться, что структура понятна, для чего следует добавить файл README.md с описанием:

- Как пользоваться системой.
- Какие эндпоинты поддерживаются.
- Как протестировать код.

#### Подготовка к отправке проекта на проверку

Необходимо проверить, что:

- Все функции проекта работают корректно и соответствуют ТЗ.
- Код оформлен и структурирован по стандартам.
- В репозитории есть описание проекта и документация по каждому модулю.
- Если используются внешние библиотеки, добавлены инструкции по их установке.

Когда проект будет готов, следует отправить ссылку на репозиторий в форму сдачи.

### Критерии оценивания

Каждый критерий оценивания содержит различные уровни соответствия критерию, в зависимости от выполнения которых можно получить разное количество баллов.

#### Критерий 1. Реализация алгоритма планирования занятости номеров

- Обработка параллельных бронирований и идемпотентность; корректная работа под нагрузкой; равномерное распределение номеров без «простаивания» (5 баллов).
- Равномерное распределение по номерам на основе статистики, предотвращение «простоя» (4 балла).
- Сортировка доступных номеров по возрастанию times_booked (при равенстве - по идентификатору) (2 балла).

#### Критерий 2. Реализация согласованности данных между сервисами

- Сага с компенсацией и устойчивость вызовов (Retry/Timeout/CircuitBreaker на взаимодействии с Hotel) (5 баллов).
- Сага с компенсацией и корректной обработкой ошибок (подтверждение/откат в зависимости от ответа Hotel) (4 балла).
- Двухшаговое подтверждение: PENDING->CONFIRMED, при сбое - CANCELLED (2 балла).

#### Критерий 3. Booking Service (CRUD бронирований)

- Расширенные сценарии: идемпотентность, пагинация, валидация дат (5 баллов).
- Проверка прав доступа и фильтрация «только свои бронирования» (4 балла).
- CRUD бронирований работает, базовые эндпойнты доступны (3 балла).

#### Критерий 4. Hotel Service (CRUD отелей и номеров, статистика)

- Фильтры/сортировки, расширенная аналитика (5 баллов).
- Выдача статистики загруженности номеров (4 балла).
- CRUD отелей и номеров работает (3 балла).

#### Критерий 5. Gateway + Eureka (маршрутизация и discovery, аутентификация)

- Маршрутизация через Gateway с фильтрами безопасности и трассировкой запросов (5 баллов).
- Интеграция с Eureka для динамического обнаружения сервисов (4 балла).
- Маршрутизация через Gateway со статическими маршрутами (2 балла).

#### Критерий 6. Безопасность (JWT, роли, Security)

- Методная безопасность (@PreAuthorize), корректные статусы ошибок (401/403), проверка ролей (5 баллов).
- Каждый сервис валидирует JWT (Resource Server); роли USER/ADMIN настроены на уровне эндпойнтов (4 балла).
- Только проверка токена на уровне Gateway без валидации в сервисах (2 балла).

#### Критерий 7. Тестирование (JUnit + MockMvc/WebTestClient)

- Полные интеграционные сценарии: параллельные брони, подтверждение и компенсация, негативные кейсы (3 балла).
- Тесты на ошибки авторизации/валидации, проверка бизнес-логики (саги, отмены брони) (2 балла).
- По одному позитивному и одному негативному тесту на ключевые эндпойнты (1 балл).

#### Критерий 8. Структура баз данных

- Расширенная схема (дополнительные поля, индексы, связи) и её документирование (2 балла).
- Структура баз данных соответствует минимальной схеме (1 балл).
- Нарушение минимальной схемы или отсутствие необходимых таблиц (0 баллов).

#### Критерий 9. Предзаполнение данных

- Предзаполнение с учётом сценариев тестирования и демонстрации бизнес-логики (2 балла).
- Реализовано базовое предзаполнение данных (1 балл).
- Данные не предзаполнены (0 баллов).

#### Критерий 10. Качество кода (SOLID, DRY/KISS/YAGNI)

- Код структурирован по SOLID, нет «божественных» классов, зависимости через интерфейсы; логика вынесена в сервисы; отсутствует копипаст (3 балла).
- Применены базовые принципы DRY/KISS/YAGNI, выделены сервисы и утилиты (2 балла).
- Есть нарушения принципов, но функциональность сохраняется (1 балл).

#### Критерий 11. Код-стиль и читаемость

- Единый стиль (форматтер/линтер), короткие методы, осмысленные имена, структура пакетов соответствует архитектуре (2 балла).
- Есть мелкие отступления, но в целом читаемо (1 балл).
- Код плохо читаем, отсутствует единый стиль (0 баллов).

#### Критерий 12. Обработка ошибок и надёжность

- Прозрачные исключения, единый ErrorDTO, корректные статусы кодов API (2 балла).
- Базовая обработка исключений реализована, но не единообразна	(1 балл).
- Отсутствует централизованная обработка ошибок	(0 баллов).

#### Критерий 13. Логирование и трассировка

- Структурные логи, ключевые события и ошибки, корреляция запросов (traceId) (2 балла).
- Логирование присутствует, но неполное или без traceId (1 балл).
- Логирование отсутствует (0 баллов).

#### Критерий 14. Документация разработчика

- README с инструкцией запуска, архитектурной схемой, ADR по ключевым решениям (2 балла).
- README присутствует, но без схемы/ADR (1 балл).
- README отсутствует (0 баллов).

#### Критерий 15. Поддерживаемость тестов

- Тесты читаемы (AAA/GWT), разумные моки, независимость от окружения (2 балла).
- Тесты написаны, но тяжело читаемы или завязаны на окружение (1 балл).
- Тесты отсутствуют (0 баллов).